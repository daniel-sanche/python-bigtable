# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

from __future__ import annotations

import inspect
import ast
import copy
import textwrap
import time
import queue

asynciomap = {
    # asyncio function to (additional globals, replacement source) tuples
    "sleep": ({"time": time}, "time.sleep"),
    "InvalidStateError": ({ValueError: ValueError}, "ValueError"),
    "Queue": ({"queue": queue}, "queue.Queue"),
}

name_map = {
    "__anext__": "__next__",
    "__aiter__": "__iter__",
    "aclose": "close",
    "AsyncIterable": "Iterable",
    "AsyncIterator": "Iterator",
    "AsyncGenerator": "Generator",
    "StopAsyncIteration": "StopIteration",
}

header = """# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

# This file is automatically generated by converter.py. Do not edit.


"""


class AsyncToSync(ast.NodeTransformer):
    def __init__(self):
        self.globals = {}

    def update_docstring(self, orig_docstring):
        orig_words = orig_docstring.split()
        new_words = [name_map.get(word, word) for word in orig_words]
        return " ".join(new_words)

    def visit_AsyncFunctionDef(self, node):
        docstring = self.update_docstring(ast.get_docstring(node))
        node.body[0].value.s = docstring
        return ast.copy_location(
            ast.FunctionDef(
                name_map.get(node.name, node.name),
                self.visit(node.args),
                [self.visit(stmt) for stmt in node.body],
                [self.visit(stmt) for stmt in node.decorator_list],
                node.returns and self.visit(node.returns),
            ),
            node,
        )

    def visit_Await(self, node):
        return self.visit(node.value)

    def visit_Attribute(self, node):
        if (
            isinstance(node.value, ast.Name)
            and isinstance(node.value.ctx, ast.Load)
            and node.value.id == "asyncio"
            and node.attr in asynciomap
        ):
            g, replacement = asynciomap[node.attr]
            self.globals.update(g)
            return ast.copy_location(
                ast.parse(replacement, mode="eval").body,
                node
            )
        elif isinstance(node, ast.Attribute) and node.attr in name_map:
            new_node = ast.copy_location(ast.Attribute(node.value, name_map[node.attr], node.ctx), node)
            return new_node
        return node

    def visit_Name(self, node):
        node.id = name_map.get(node.id, node.id)
        return node


def transform_sync(in_obj, save_path=None):
    filename = inspect.getfile(in_obj)
    lines, lineno = inspect.getsourcelines(in_obj)
    ast_tree = ast.parse(textwrap.dedent(''.join(lines)), filename)
    # update name
    ast_tree.body[0].name = f"{ast_tree.body[0].name}_Sync"
    ast.increment_lineno(ast_tree, lineno - 1)

    transformer = AsyncToSync()
    transformer.visit(ast_tree)
    str_tree = ast.unparse(ast_tree)
    if save_path:
        with open(save_path, 'w') as f:
            f.write(header)
            f.write(str_tree)
    # tranformed_globals = {**f.__globals__, **transformer.globals}
    # exec(compile(ast_tree, filename, 'exec'), tranformed_globals)
    # return tranformed_globals[f.__name__]

if __name__ == "__main__":
    from google.cloud.bigtable._read_rows import _ReadRowsOperation
    obj = transform_sync(_ReadRowsOperation, save_path='output.py')

    # transformable = [_ReadRowsOperation]
    # for cls in transformable:
    #     for name, f in inspect.getmembers(cls, inspect.isfunction):
    #         setattr(cls, name, transform_sync(f))

    # sync_ = transform_sync(foo)
    # foo()
